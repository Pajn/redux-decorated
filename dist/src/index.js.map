{"version":3,"sources":["index.js","../../src/index.ts"],"names":["Object","defineProperty","exports","value","createActions","actions","prefix","freeze","keys","reduce","type","assign","action","payload","createReducer","initialState","anyHandlers","subHandlers","actionHandlers","reducer","state","handler","subHandler","filter","actionHandler","builder","any","push","with","key","subState","when","newState","build","clone","object","Array","isArray","updateIn","path","newValue","updateInAny","arguments","length","slice","cloned","removeIn","removeInAny","splice"],"mappings":"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","file":"index.js","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction createActions(actions, { prefix = '' } = {}) {\n    return Object.freeze(Object.keys(actions).reduce((actions, type) => (Object.assign({}, actions, { [type]: Object.assign({ type: `${prefix}${type}` }, actions[type]) })), actions));\n}\nexports.createActions = createActions;\nfunction action(action, payload) {\n    return {\n        type: action.type,\n        payload,\n    };\n}\nexports.action = action;\nfunction createReducer(initialState) {\n    const anyHandlers = [];\n    const subHandlers = [];\n    const actionHandlers = [];\n    function reducer(state, action) {\n        state = anyHandlers\n            .reduce((state, handler) => handler(state, action), state || initialState);\n        state = subHandlers\n            .reduce((state, subHandler) => subHandler.handler(state, action), state || initialState);\n        return actionHandlers\n            .filter(actionHandler => actionHandler.type === action.type)\n            .reduce((state, actionHandler) => actionHandler.handler(state, action.payload), state || initialState);\n    }\n    const builder = function builder(state, action) {\n        return reducer(state, action);\n    };\n    builder.any = handler => {\n        anyHandlers.push(handler);\n        return builder;\n    };\n    builder.with = (key, handler) => {\n        subHandlers.push({\n            key,\n            handler: (state, action) => {\n                const subState = handler(state && state[key], action);\n                if (subState) {\n                    return Object.assign({}, state, { [key]: subState });\n                }\n                return state;\n            },\n        });\n        return builder;\n    };\n    builder.when = (action, handler) => {\n        actionHandlers.push({ type: action.type, handler: (state, action) => {\n                const newState = handler(state, action);\n                if (typeof newState === 'function') {\n                    return newState(state);\n                }\n                return newState;\n            } });\n        return builder;\n    };\n    builder.build = () => reducer;\n    return builder;\n}\nexports.createReducer = createReducer;\nfunction clone(object) {\n    return Array.isArray(object)\n        ? [...object]\n        : Object.assign({}, object);\n}\nexports.clone = clone;\nfunction updateIn(path, newValue, object) {\n    return updateInAny(path, newValue, object);\n}\nexports.updateIn = updateIn;\nfunction updateInAny(path, newValue, object) {\n    if (arguments.length === 2) {\n        return (object) => updateInAny(path, newValue, object);\n    }\n    if (Array.isArray(path) && path.length > 1) {\n        newValue = updateInAny(path.slice(1), newValue, (object || {})[path[0]]);\n    }\n    const key = Array.isArray(path) ? path[0] : path;\n    const cloned = clone(object);\n    cloned[key] = newValue;\n    return cloned;\n}\nexports.updateInAny = updateInAny;\nfunction removeIn(path, object) {\n    return removeInAny(path, object);\n}\nexports.removeIn = removeIn;\nfunction removeInAny(path, object) {\n    if (arguments.length === 1) {\n        return (object) => removeInAny(path, object);\n    }\n    if (Array.isArray(path) && path.length > 1) {\n        const newValue = removeInAny(path.slice(1), (object || {})[path[0]]);\n        return updateInAny(path[0], newValue, object);\n    }\n    const key = Array.isArray(path) ? path[0] : path;\n    const cloned = clone(object);\n    if (Array.isArray(cloned)) {\n        cloned.splice(key, 1);\n    }\n    else {\n        delete cloned[key];\n    }\n    return cloned;\n}\nexports.removeInAny = removeInAny;\n","export type Key = string | number\nexport type Reducer<S> = (state: S, action: Action<any>) => S\n\nexport interface Action<T extends {}> {\n  type?: string\n  payload?: T\n  [key: string]: any\n}\n\nexport interface BuildableReducer<S> {\n  (state: S, action): S\n  any<P>(handler: Reducer<S>): this\n  with<K extends keyof S>(key: K, handler: Reducer<S[K]>): this\n  when<P>(action: Action<P>, handler: (state: S, payload: P) => S | ((state: S) => S)): this\n  build(): Reducer<S>\n}\n\nexport function createActions<T>(actions: T, {prefix = ''}: {prefix?: string} = {}): T {\n  return Object.freeze(\n    Object.keys(actions).reduce(\n      (actions, type) => ({\n        ...actions as any,\n        [type]: {type: `${prefix}${type}`, ...actions[type]},\n      }),\n      actions\n    )\n  )\n}\n\nexport function action<T>(action: Action<T>, payload: T): Action<T> & {type: string} {\n  return {\n    type: action.type!,\n    payload,\n  }\n}\n\ntype AnyHandler = Reducer<any>\ntype SubHandler = {\n  key: string\n  handler: (state, action) => any\n}\ntype ActionHandler = {\n  type: string\n  handler: Reducer<any>\n}\n\nexport function createReducer<T>(initialState: T): BuildableReducer<T> {\n  const anyHandlers: Array<AnyHandler> = []\n  const subHandlers: Array<SubHandler> = []\n  const actionHandlers: Array<ActionHandler> = []\n\n  function reducer(state, action) {\n    state = anyHandlers\n      .reduce(\n        (state, handler) => handler(state, action),\n        state || initialState\n      )\n    state = subHandlers\n      .reduce(\n        (state, subHandler) => subHandler.handler(state, action),\n        state || initialState\n      )\n    return actionHandlers\n      .filter(actionHandler => actionHandler.type === action.type)\n      .reduce(\n        (state, actionHandler) => actionHandler.handler(state, action.payload),\n        state || initialState\n      )\n  }\n\n  const builder = function builder(state, action) {\n    return reducer(state, action)\n  } as BuildableReducer<any>\n\n  builder.any = handler => {\n    anyHandlers.push(handler)\n    return builder\n  }\n\n  builder.with = (key, handler) => {\n    subHandlers.push({\n      key,\n      handler: (state, action) => {\n        const subState = handler(state && state[key], action)\n        if (subState) {\n          return {\n            ...state,\n            [key]: subState,\n          }\n        }\n        return state\n      },\n    })\n    return builder\n  }\n\n  builder.when = (action, handler) => {\n    actionHandlers.push({type: action.type, handler: (state, action) => {\n      const newState = handler(state, action)\n\n      if (typeof newState === 'function') {\n        return newState(state)\n      }\n      return newState\n    }})\n    return builder\n  }\n\n  builder.build = () => reducer\n\n  return builder\n}\n\nexport function clone<T>(object: T): T {\n  return Array.isArray(object)\n    ? [...object]\n    : {...object as any}\n}\n\nexport function updateIn<E, T extends Array<E>>(index: number, newValue: E, object: T): T\nexport function updateIn<T, K extends keyof T>(path: K, newValue: T[K], object: T): T\nexport function updateIn<T, KA extends keyof T, KB extends keyof T[KA]>(path: [KA, KB], newValue: T[KA][KB], object: T): T\nexport function updateIn<T, KA extends keyof T, KB extends keyof T[KA], KC extends keyof T[KA][KB]>(path: [KA, KB, KC], newValue: T[KA][KB][KC], object: T): T\nexport function updateIn(path, newValue, object) {\n  return updateInAny(path, newValue, object)\n}\nexport function updateInAny(path: Key|Array<Key>, newValue: any): (object: any) => any\nexport function updateInAny<T>(path: Key|Array<Key>, newValue: any, object: T): T\nexport function updateInAny<T>(path: Key|Array<Key>, newValue: any, object?) {\n  if (arguments.length === 2) {\n    return (object) => updateInAny(path, newValue, object)\n  }\n\n  if (Array.isArray(path) && path.length > 1) {\n    newValue = updateInAny(path.slice(1), newValue, (object || {})[path[0]])\n  }\n\n  const key = Array.isArray(path) ? path[0] : path\n  const cloned = clone(object)\n  cloned[key] = newValue\n\n  return cloned\n}\n\nexport function removeIn<T extends Array<any>>(index: number, object: T): T\nexport function removeIn<T, K extends keyof T>(path: K, object: T): T\nexport function removeIn<T, KA extends keyof T, KB extends keyof T[KA]>(path: [KA, KB], object: T): T\nexport function removeIn<T, KA extends keyof T, KB extends keyof T[KA], KC extends keyof T[KA][KB]>(path: [KA, KB, KC], object: T): T\nexport function removeIn(path, object) {\n  return removeInAny(path, object)\n}\nexport function removeInAny(path: Key|Array<Key>): (object: any) => any\nexport function removeInAny<T>(path: Key|Array<Key>, object: T): T\nexport function removeInAny<T>(path: Key|Array<Key>, object?) {\n  if (arguments.length === 1) {\n    return (object) => removeInAny(path, object)\n  }\n\n  if (Array.isArray(path) && path.length > 1) {\n    const newValue = removeInAny(path.slice(1), (object || {})[path[0]])\n    return updateInAny(path[0], newValue, object)\n  }\n\n  const key = Array.isArray(path) ? path[0] : path\n  const cloned = clone(object)\n  if (Array.isArray(cloned)) {\n    cloned.splice(key as number, 1)\n  } else {\n    delete cloned[key]\n  }\n\n  return cloned\n}\n"]}